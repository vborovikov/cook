/*
 * This file was generated by Spryer.Scripting 0.9.11-beta.14+main.0918c35
 * https://github.com/vborovikov/spryer
 *
 * Generated: 2025-03-24 18:24:58
 * Source: Scripts.sql 0.2.1
 * Scripts: 16
 */

namespace Sage.Web.Data;

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading.Tasks;
using Dapper;
using Spryer;
using Pantry;

/// <summary>
/// Provides extension methods for the database operations
/// described in the script file Scripts.sql.
/// </summary>
internal static partial class ScriptsSqlExtensions
{
    /// <summary>
    /// The <see cref="DbScriptMap"/> instance for this class.
    /// </summary>
    private static readonly DbScriptMap sql;

    /// <summary>
    /// Loads the SQL scripts from the file Scripts.sql.
    /// </summary>
    static ScriptsSqlExtensions()
    {
        sql = DbScriptMap.Load("Scripts.sql");
    }

    /// <summary>
    /// Executes a query and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     if @RecipeId is null
    ///         select top 1 @RecipeId = r.Id
    ///         from book.Recipes r
    ///         tablesample (1000 rows)
    ///         order by crypt_gen_random(4);
    ///
    ///     select r.Id, r.Name, rs.Link, r.Description, r.Instructions,
    ///         json_query((
    ///             select i.Id, i.Description
    ///             from book.Ingredients i
    ///             inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///             where ri.RecipeId = r.Id
    ///             order by ri.Turn
    ///             for json path
    ///         )) as Ingredients
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     where r.Id = @RecipeId
    ///     for json path, without_array_wrapper;
    /// </code>
    /// </remarks>
    public static Task<T?> GetRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["GetRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a query and returns the first result.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first result.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select r.Content as Recipe, r.Link as Source
    ///     from book.RecipeSources r
    ///     where r.RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<T> GetImportedRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryFirstAsync<T>(sql["GetImportedRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Recipes (Id, Name, Description, Instructions, IsParsed)
    ///     values (@Id, @Name, @Description, @Instructions, @IsParsed);
    ///
    ///     insert into book.RecipeSources (RecipeId, Content, ContentType, Link)
    ///     values (@Id, @Content, 'text', @Link);
    /// </code>
    /// </remarks>
    public static Task<int> ImportRecipeAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["ImportRecipe"],
            param: new
            {
                Id = id,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar(),
                IsParsed = isParsed,
                Content = content.AsNVarChar(),
                Link = link.AsNVarChar(850)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Recipes (Id, Name, Description, Instructions, IsParsed)
    ///     values (@Id, @Name, @Description, @Instructions, @IsParsed);
    ///
    ///     insert into book.RecipeSources (RecipeId, Content, ContentType, Link)
    ///     values (@Id, @Content, 'text', @Link);
    /// </code>
    /// </remarks>
    public static Task<int> ImportRecipeAsync(this DbTransaction transaction,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return ImportRecipeAsync(transaction.Connection!,
            id, name, description, instructions, isParsed, content, link,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete i from book.Ingredients i
    ///     inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///     where ri.RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> DiscardIngredientsAsync(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["DiscardIngredients"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete i from book.Ingredients i
    ///     inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///     where ri.RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> DiscardIngredientsAsync(this DbTransaction transaction,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return DiscardIngredientsAsync(transaction.Connection!,
            recipeId,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions, IsParsed = @IsParsed
    ///     where Id = @RecipeId;
    ///
    ///     update book.RecipeSources
    ///     set Content = @Content, ContentType = 'text', Link = @Link
    ///     where RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateImportedRecipeAsync(this DbConnection connection,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateImportedRecipe"],
            param: new
            {
                RecipeId = recipeId,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar(),
                IsParsed = isParsed,
                Content = content.AsNVarChar(),
                Link = link.AsNVarChar(850)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions, IsParsed = @IsParsed
    ///     where Id = @RecipeId;
    ///
    ///     update book.RecipeSources
    ///     set Content = @Content, ContentType = 'text', Link = @Link
    ///     where RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateImportedRecipeAsync(this DbTransaction transaction,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return UpdateImportedRecipeAsync(transaction.Connection!,
            recipeId, name, description, instructions, isParsed, content, link,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Ingredients (Description,
    ///         Number, NumberValue, NumberUnit,
    ///         Quantity, QuantityValue, QuantityUnit,
    ///         AltQuantity, AltQuantityValue, AltQuantityUnit)
    ///     output inserted.Id
    ///     values (@Description,
    ///         @Number, @NumberValue, @NumberUnit,
    ///         @Quantity, @QuantityValue, @QuantityUnit,
    ///         @AltQuantity, @AltQuantityValue, @AltQuantityUnit);
    /// </code>
    /// </remarks>
    public static Task<T?> StoreIngredientsAsync<T>(this DbConnection connection,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteScalarAsync<T>(sql["StoreIngredients"],
            param: new
            {
                Description = description.AsNVarChar(100),
                Number = number,
                NumberValue = numberValue,
                NumberUnit = numberUnit,
                Quantity = quantity,
                QuantityValue = quantityValue,
                QuantityUnit = quantityUnit,
                AltQuantity = altQuantity,
                AltQuantityValue = altQuantityValue,
                AltQuantityUnit = altQuantityUnit
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Ingredients (Description,
    ///         Number, NumberValue, NumberUnit,
    ///         Quantity, QuantityValue, QuantityUnit,
    ///         AltQuantity, AltQuantityValue, AltQuantityUnit)
    ///     output inserted.Id
    ///     values (@Description,
    ///         @Number, @NumberValue, @NumberUnit,
    ///         @Quantity, @QuantityValue, @QuantityUnit,
    ///         @AltQuantity, @AltQuantityValue, @AltQuantityUnit);
    /// </code>
    /// </remarks>
    public static Task<T?> StoreIngredientsAsync<T>(this DbTransaction transaction,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return StoreIngredientsAsync<T>(transaction.Connection!,
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="turn">The query parameter Turn of type Byte.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.RecipeIngredients (RecipeId, IngredientId, Turn)
    ///     values (@RecipeId, @IngredientId, @Turn);
    /// </code>
    /// </remarks>
    public static Task<int> StoreRecipeIngredientsAsync(this DbConnection connection,
        Guid? recipeId, Guid? ingredientId, byte turn,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["StoreRecipeIngredients"],
            param: new
            {
                RecipeId = recipeId,
                IngredientId = ingredientId,
                Turn = turn
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="turn">The query parameter Turn of type Byte.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.RecipeIngredients (RecipeId, IngredientId, Turn)
    ///     values (@RecipeId, @IngredientId, @Turn);
    /// </code>
    /// </remarks>
    public static Task<int> StoreRecipeIngredientsAsync(this DbTransaction transaction,
        Guid? recipeId, Guid? ingredientId, byte turn,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return StoreRecipeIngredientsAsync(transaction.Connection!,
            recipeId, ingredientId, turn,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a query and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select r.Id, r.Name, r.Description, r.Instructions,
    ///         json_query((
    ///             select i.Id, i.Description,
    ///                 i.Number, i.Quantity, i.AltQuantity,
    ///                 json_query((
    ///                     select f.FoodId as Id, fs.Name
    ///                     from book.IngredientFoods f
    ///                     inner join book.Foods fs on fs.Id = f.FoodId
    ///                     where f.IngredientId = i.Id
    ///                     for json path
    ///                 )) as Foods
    ///             from book.Ingredients i
    ///             inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///             where ri.RecipeId = r.Id
    ///             order by ri.Turn
    ///             for json path
    ///         )) as Ingredients
    ///     from book.Recipes r
    ///     where r.Id = @RecipeId
    ///     for json path, without_array_wrapper;
    /// </code>
    /// </remarks>
    public static Task<T?> EditRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["EditRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a query and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select f.Id, f.Name
    ///     from book.Foods f
    ///     where f.Name like '%' + @Name + '%'
    ///     for json path;
    /// </code>
    /// </remarks>
    public static Task<T?> GetFoodsByNameAsync<T>(this DbConnection connection,
        string? name,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["GetFoodsByName"],
            param: new
            {
                Name = name.AsNVarChar(50)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateRecipeDetailsAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateRecipeDetails"],
            param: new
            {
                Id = id,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar()
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateRecipeDetailsAsync(this DbTransaction transaction,
        Guid? id, string? name, string? description, string? instructions,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return UpdateRecipeDetailsAsync(transaction.Connection!,
            id, name, description, instructions,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Ingredients
    ///     set Description = @Description,
    ///         Number = @Number, NumberValue = @NumberValue, NumberUnit = @NumberUnit,
    ///         Quantity = @Quantity, QuantityValue = @QuantityValue, QuantityUnit = @QuantityUnit,
    ///         AltQuantity = @AltQuantity, AltQuantityValue = @AltQuantityValue, AltQuantityUnit = @AltQuantityUnit
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateIngredientAsync(this DbConnection connection,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateIngredient"],
            param: new
            {
                Id = id,
                Description = description.AsNVarChar(100),
                Number = number,
                NumberValue = numberValue,
                NumberUnit = numberUnit,
                Quantity = quantity,
                QuantityValue = quantityValue,
                QuantityUnit = quantityUnit,
                AltQuantity = altQuantity,
                AltQuantityValue = altQuantityValue,
                AltQuantityUnit = altQuantityUnit
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Ingredients
    ///     set Description = @Description,
    ///         Number = @Number, NumberValue = @NumberValue, NumberUnit = @NumberUnit,
    ///         Quantity = @Quantity, QuantityValue = @QuantityValue, QuantityUnit = @QuantityUnit,
    ///         AltQuantity = @AltQuantity, AltQuantityValue = @AltQuantityValue, AltQuantityUnit = @AltQuantityUnit
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateIngredientAsync(this DbTransaction transaction,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return UpdateIngredientAsync(transaction.Connection!,
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete from book.IngredientFoods
    ///     where IngredientId = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> DeleteIngredientFoodsAsync(this DbConnection connection,
        Guid? id,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["DeleteIngredientFoods"],
            param: new
            {
                Id = id
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete from book.IngredientFoods
    ///     where IngredientId = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> DeleteIngredientFoodsAsync(this DbTransaction transaction,
        Guid? id,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return DeleteIngredientFoodsAsync(transaction.Connection!,
            id,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="shortName">The query parameter ShortName of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Foods (Name, ShortName)
    ///     output inserted.Id
    ///     values (@Name, @ShortName);
    /// </code>
    /// </remarks>
    public static Task<T?> AddFoodAsync<T>(this DbConnection connection,
        string? name, string? shortName,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteScalarAsync<T>(sql["AddFood"],
            param: new
            {
                Name = name.AsNVarChar(50),
                ShortName = shortName.AsNVarChar(50)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="shortName">The query parameter ShortName of type String.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Foods (Name, ShortName)
    ///     output inserted.Id
    ///     values (@Name, @ShortName);
    /// </code>
    /// </remarks>
    public static Task<T?> AddFoodAsync<T>(this DbTransaction transaction,
        string? name, string? shortName,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return AddFoodAsync<T>(transaction.Connection!,
            name, shortName,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="foodId">The query parameter FoodId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.IngredientFoods (IngredientId, FoodId)
    ///     values (@IngredientId, @FoodId);
    /// </code>
    /// </remarks>
    public static Task<int> ConnectIngredientFoodAsync(this DbConnection connection,
        Guid? ingredientId, Guid? foodId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["ConnectIngredientFood"],
            param: new
            {
                IngredientId = ingredientId,
                FoodId = foodId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a command and returns the number of rows affected.
    /// </summary>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="foodId">The query parameter FoodId of type Guid.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.IngredientFoods (IngredientId, FoodId)
    ///     values (@IngredientId, @FoodId);
    /// </code>
    /// </remarks>
    public static Task<int> ConnectIngredientFoodAsync(this DbTransaction transaction,
        Guid? ingredientId, Guid? foodId,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return ConnectIngredientFoodAsync(transaction.Connection!,
            ingredientId, foodId,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a query and returns the results as an <see cref="IEnumerable{T}" />.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="parameters">The query parameter Parameters of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The results as an <see cref="IEnumerable{T}" />.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select @TotalCount = count(r.Id)
    ///     from book.Recipes r;
    ///
    ///     select @FilterCount = count(r.Id)
    ///     from book.Recipes r
    ///     inner join freetexttable(book.Recipes, Name, @Search, @TopN) ft on ft.[Key] = r.Id;
    ///
    ///     select r.Id, r.Name, rs.Link, r.Description
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     inner join freetexttable(book.Recipes, Name, @Search, @TopN) ft on ft.[Key] = r.Id
    ///     order by ft.Rank desc, len(r.Instructions) desc
    ///     offset @SkipCount rows fetch next @TakeCount rows only;
    /// </code>
    /// </remarks>
    public static Task<IEnumerable<T>> SearchRecipesFullTextAsync<T>(this DbConnection connection,
        object parameters,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryAsync<T>(sql["SearchRecipesFullText"],
            param: parameters,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <summary>
    /// Executes a query and returns the results as an <see cref="IEnumerable{T}" />.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="parameters">The query parameter Parameters of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The results as an <see cref="IEnumerable{T}" />.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select @TotalCount = count(r.Id)
    ///     from book.Recipes r;
    ///
    ///     --select @FilterCount = count(distinct r.Id)
    ///     --from book.Recipes r
    ///     --left outer join book.RecipeFoods rf on rf.RecipeId = r.Id
    ///     --left outer join book.Foods f on f.Id = rf.FoodId
    ///     --where
    ///     --    charindex(@Search, r.Name) > 0 or
    ///     --    charindex(@Search, r.Description) > 0 or
    ///     --    charindex(@Search, r.Instructions) > 0 or
    ///     --    charindex(@Search, f.Name) > 0;
    ///
    ///     select distinct r.Id, r.Name, rs.Link, r.Description, len(r.Instructions) as Care
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     left outer join book.RecipeFoods rf on rf.RecipeId = r.Id
    ///     left outer join book.Foods f on f.Id = rf.FoodId
    ///     where
    ///         charindex(@Search, r.Name) > 0 or
    ///         charindex(@Search, r.Description) > 0 or
    ///         charindex(@Search, r.Instructions) > 0 or
    ///         charindex(@Search, f.Name) > 0
    ///     order by Care desc
    ///     offset @SkipCount rows fetch next @TakeCount rows only;
    ///
    ///     select @FilterCount = @@RowCount;
    /// </code>
    /// </remarks>
    public static Task<IEnumerable<T>> SearchRecipesAsync<T>(this DbConnection connection,
        object parameters,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryAsync<T>(sql["SearchRecipes"],
            param: parameters,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }
}
