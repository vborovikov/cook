/*
 * This file was generated by Spryer.Scripting 0.9.11-beta.24+main.5f54f98
 * https://github.com/vborovikov/spryer
 *
 * Generated: 2025-05-17 18:53:09
 * Source: Scripts.sql 0.2.1
 * Scripts: 16
 */

namespace Sage.Web.Data;

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using Dapper;
using Spryer;
using Pantry;

/// <summary>
/// Provides extension methods for the database operations
/// described in the script file Scripts.sql.
/// </summary>
internal static partial class ScriptsSqlExtensions
{
    /// <summary>
    /// The <see cref="DbScriptMap"/> instance for this class.
    /// </summary>
    private static readonly DbScriptMap sql;

    /// <summary>
    /// Loads the SQL scripts from the file Scripts.sql.
    /// </summary>
    static ScriptsSqlExtensions()
    {
        sql = DbScriptMap.Load("Scripts.sql");
    }

    /// <summary>
    /// Executes a query 'GetRecipeById' and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     if @RecipeId is null
    ///         select top 1 @RecipeId = r.Id
    ///         from book.Recipes r
    ///         tablesample (1000 rows)
    ///         order by crypt_gen_random(4);
    ///
    ///     select r.Id, r.Name, rs.Link, r.Description, r.Instructions,
    ///         json_query((
    ///             select i.Id, i.Description
    ///             from book.Ingredients i
    ///             inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///             where ri.RecipeId = r.Id
    ///             order by ri.Turn
    ///             for json path
    ///         )) as Ingredients
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     where r.Id = @RecipeId
    ///     for json path, without_array_wrapper;
    /// </code>
    /// </remarks>
    public static Task<T?> GetRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["GetRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="GetRecipeByIdAsync"/>
    public static async Task<T?> GetRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.GetRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="GetRecipeByIdAsync"/>
    public static Task<T?> GetRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return database.GetRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a query 'GetImportedRecipeById' and returns the first result.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first result.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select r.Content as Recipe, r.Link as Source
    ///     from book.RecipeSources r
    ///     where r.RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<T> GetImportedRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryFirstAsync<T>(sql["GetImportedRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="GetImportedRecipeByIdAsync"/>
    public static async Task<T> GetImportedRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.GetImportedRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="GetImportedRecipeByIdAsync"/>
    public static Task<T> GetImportedRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return database.GetImportedRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'ImportRecipe' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Recipes (Id, Name, Description, Instructions, IsParsed)
    ///     values (@Id, @Name, @Description, @Instructions, @IsParsed);
    ///
    ///     insert into book.RecipeSources (RecipeId, Content, ContentType, Link)
    ///     values (@Id, @Content, 'text', @Link);
    /// </code>
    /// </remarks>
    public static Task<int> ImportRecipeAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["ImportRecipe"],
            param: new
            {
                Id = id,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar(),
                IsParsed = isParsed,
                Content = content.AsNVarChar(),
                Link = link.AsNVarChar(850)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static async Task<int> ImportRecipeAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.ImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static Task<int> ImportRecipeAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return database.ImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static Task<int> ImportRecipeAsync(this DbTransaction transaction,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.ImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static async Task<int> CommitImportRecipeAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.ImportRecipeAsync(
                id, name, description, instructions, isParsed, content, link,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static Task<int> CommitImportRecipeAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return connection.CommitImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static async Task<int> CommitImportRecipeAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="ImportRecipeAsync"/>
    public static Task<int> CommitImportRecipeAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return database.CommitImportRecipeAsync(
            id, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'DiscardIngredients' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete i from book.Ingredients i
    ///     inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///     where ri.RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> DiscardIngredientsAsync(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["DiscardIngredients"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static async Task<int> DiscardIngredientsAsync(this DbDataSource database,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.DiscardIngredientsAsync(
            recipeId,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static Task<int> DiscardIngredientsAsync(this DbDataSource database,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return database.DiscardIngredientsAsync(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static Task<int> DiscardIngredientsAsync(this DbTransaction transaction,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.DiscardIngredientsAsync(
            recipeId,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static async Task<int> CommitDiscardIngredientsAsync(this DbConnection connection,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.DiscardIngredientsAsync(
                recipeId,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static Task<int> CommitDiscardIngredientsAsync(this DbConnection connection,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return connection.CommitDiscardIngredientsAsync(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static async Task<int> CommitDiscardIngredientsAsync(this DbDataSource database,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitDiscardIngredientsAsync(
            recipeId,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="DiscardIngredientsAsync"/>
    public static Task<int> CommitDiscardIngredientsAsync(this DbDataSource database,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return database.CommitDiscardIngredientsAsync(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'UpdateImportedRecipe' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="isParsed">The query parameter IsParsed of type Boolean.</param>
    /// <param name="content">The query parameter Content of type String.</param>
    /// <param name="link">The query parameter Link of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions, IsParsed = @IsParsed
    ///     where Id = @RecipeId;
    ///
    ///     update book.RecipeSources
    ///     set Content = @Content, ContentType = 'text', Link = @Link
    ///     where RecipeId = @RecipeId;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateImportedRecipeAsync(this DbConnection connection,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateImportedRecipe"],
            param: new
            {
                RecipeId = recipeId,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar(),
                IsParsed = isParsed,
                Content = content.AsNVarChar(),
                Link = link.AsNVarChar(850)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static async Task<int> UpdateImportedRecipeAsync(this DbDataSource database,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.UpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static Task<int> UpdateImportedRecipeAsync(this DbDataSource database,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return database.UpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static Task<int> UpdateImportedRecipeAsync(this DbTransaction transaction,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.UpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static async Task<int> CommitUpdateImportedRecipeAsync(this DbConnection connection,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.UpdateImportedRecipeAsync(
                recipeId, name, description, instructions, isParsed, content, link,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static Task<int> CommitUpdateImportedRecipeAsync(this DbConnection connection,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return connection.CommitUpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static async Task<int> CommitUpdateImportedRecipeAsync(this DbDataSource database,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitUpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateImportedRecipeAsync"/>
    public static Task<int> CommitUpdateImportedRecipeAsync(this DbDataSource database,
        Guid? recipeId, string? name, string? description, string? instructions, bool isParsed, string? content, string? link,
        CancellationToken cancellationToken)
    {
        return database.CommitUpdateImportedRecipeAsync(
            recipeId, name, description, instructions, isParsed, content, link,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'StoreIngredients' and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Ingredients (Description,
    ///         Number, NumberValue, NumberUnit,
    ///         Quantity, QuantityValue, QuantityUnit,
    ///         AltQuantity, AltQuantityValue, AltQuantityUnit)
    ///     output inserted.Id
    ///     values (@Description,
    ///         @Number, @NumberValue, @NumberUnit,
    ///         @Quantity, @QuantityValue, @QuantityUnit,
    ///         @AltQuantity, @AltQuantityValue, @AltQuantityUnit);
    /// </code>
    /// </remarks>
    public static Task<T?> StoreIngredientsAsync<T>(this DbConnection connection,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteScalarAsync<T>(sql["StoreIngredients"],
            param: new
            {
                Description = description.AsNVarChar(100),
                Number = number,
                NumberValue = numberValue,
                NumberUnit = numberUnit,
                Quantity = quantity,
                QuantityValue = quantityValue,
                QuantityUnit = quantityUnit,
                AltQuantity = altQuantity,
                AltQuantityValue = altQuantityValue,
                AltQuantityUnit = altQuantityUnit
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static async Task<T?> StoreIngredientsAsync<T>(this DbDataSource database,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.StoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static Task<T?> StoreIngredientsAsync<T>(this DbDataSource database,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return database.StoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static Task<T?> StoreIngredientsAsync<T>(this DbTransaction transaction,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.StoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static async Task<T?> CommitStoreIngredientsAsync<T>(this DbConnection connection,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.StoreIngredientsAsync<T>(
                description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static Task<T?> CommitStoreIngredientsAsync<T>(this DbConnection connection,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return connection.CommitStoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static async Task<T?> CommitStoreIngredientsAsync<T>(this DbDataSource database,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitStoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="StoreIngredientsAsync"/>
    public static Task<T?> CommitStoreIngredientsAsync<T>(this DbDataSource database,
        string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return database.CommitStoreIngredientsAsync<T>(
            description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'StoreRecipeIngredients' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="turn">The query parameter Turn of type Byte.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.RecipeIngredients (RecipeId, IngredientId, Turn)
    ///     values (@RecipeId, @IngredientId, @Turn);
    /// </code>
    /// </remarks>
    public static Task<int> StoreRecipeIngredientsAsync(this DbConnection connection,
        Guid? recipeId, Guid? ingredientId, byte turn,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["StoreRecipeIngredients"],
            param: new
            {
                RecipeId = recipeId,
                IngredientId = ingredientId,
                Turn = turn
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static async Task<int> StoreRecipeIngredientsAsync(this DbDataSource database,
        Guid? recipeId, Guid? ingredientId, byte turn,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.StoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static Task<int> StoreRecipeIngredientsAsync(this DbDataSource database,
        Guid? recipeId, Guid? ingredientId, byte turn,
        CancellationToken cancellationToken)
    {
        return database.StoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static Task<int> StoreRecipeIngredientsAsync(this DbTransaction transaction,
        Guid? recipeId, Guid? ingredientId, byte turn,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.StoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static async Task<int> CommitStoreRecipeIngredientsAsync(this DbConnection connection,
        Guid? recipeId, Guid? ingredientId, byte turn,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.StoreRecipeIngredientsAsync(
                recipeId, ingredientId, turn,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static Task<int> CommitStoreRecipeIngredientsAsync(this DbConnection connection,
        Guid? recipeId, Guid? ingredientId, byte turn,
        CancellationToken cancellationToken)
    {
        return connection.CommitStoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static async Task<int> CommitStoreRecipeIngredientsAsync(this DbDataSource database,
        Guid? recipeId, Guid? ingredientId, byte turn,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitStoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="StoreRecipeIngredientsAsync"/>
    public static Task<int> CommitStoreRecipeIngredientsAsync(this DbDataSource database,
        Guid? recipeId, Guid? ingredientId, byte turn,
        CancellationToken cancellationToken)
    {
        return database.CommitStoreRecipeIngredientsAsync(
            recipeId, ingredientId, turn,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a query 'EditRecipeById' and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="recipeId">The query parameter RecipeId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select r.Id, r.Name, r.Description, r.Instructions,
    ///         json_query((
    ///             select i.Id, i.Description,
    ///                 i.Number, i.Quantity, i.AltQuantity,
    ///                 json_query((
    ///                     select f.FoodId as Id, fs.Name
    ///                     from book.IngredientFoods f
    ///                     inner join book.Foods fs on fs.Id = f.FoodId
    ///                     where f.IngredientId = i.Id
    ///                     for json path
    ///                 )) as Foods
    ///             from book.Ingredients i
    ///             inner join book.RecipeIngredients ri on ri.IngredientId = i.Id
    ///             where ri.RecipeId = r.Id
    ///             order by ri.Turn
    ///             for json path
    ///         )) as Ingredients
    ///     from book.Recipes r
    ///     where r.Id = @RecipeId
    ///     for json path, without_array_wrapper;
    /// </code>
    /// </remarks>
    public static Task<T?> EditRecipeByIdAsync<T>(this DbConnection connection,
        Guid? recipeId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["EditRecipeById"],
            param: new
            {
                RecipeId = recipeId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="EditRecipeByIdAsync"/>
    public static async Task<T?> EditRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.EditRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="EditRecipeByIdAsync"/>
    public static Task<T?> EditRecipeByIdAsync<T>(this DbDataSource database,
        Guid? recipeId,
        CancellationToken cancellationToken)
    {
        return database.EditRecipeByIdAsync<T>(
            recipeId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a query 'GetFoodsByName' and returns the result as a JSON object.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The result as a JSON object.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select f.Id, f.Name
    ///     from book.Foods f
    ///     where f.Name like '%' + @Name + '%'
    ///     for json path;
    /// </code>
    /// </remarks>
    public static Task<T?> GetFoodsByNameAsync<T>(this DbConnection connection,
        string? name,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryJsonAsync<T>(sql["GetFoodsByName"],
            param: new
            {
                Name = name.AsNVarChar(50)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="GetFoodsByNameAsync"/>
    public static async Task<T?> GetFoodsByNameAsync<T>(this DbDataSource database,
        string? name,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.GetFoodsByNameAsync<T>(
            name,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="GetFoodsByNameAsync"/>
    public static Task<T?> GetFoodsByNameAsync<T>(this DbDataSource database,
        string? name,
        CancellationToken cancellationToken)
    {
        return database.GetFoodsByNameAsync<T>(
            name,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'UpdateRecipeDetails' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="instructions">The query parameter Instructions of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Recipes
    ///     set Name = @Name, Description = @Description, Instructions = @Instructions
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateRecipeDetailsAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateRecipeDetails"],
            param: new
            {
                Id = id,
                Name = name.AsNVarChar(100),
                Description = description.AsNVarChar(500),
                Instructions = instructions.AsNVarChar()
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static async Task<int> UpdateRecipeDetailsAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.UpdateRecipeDetailsAsync(
            id, name, description, instructions,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static Task<int> UpdateRecipeDetailsAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions,
        CancellationToken cancellationToken)
    {
        return database.UpdateRecipeDetailsAsync(
            id, name, description, instructions,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static Task<int> UpdateRecipeDetailsAsync(this DbTransaction transaction,
        Guid? id, string? name, string? description, string? instructions,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.UpdateRecipeDetailsAsync(
            id, name, description, instructions,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static async Task<int> CommitUpdateRecipeDetailsAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.UpdateRecipeDetailsAsync(
                id, name, description, instructions,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static Task<int> CommitUpdateRecipeDetailsAsync(this DbConnection connection,
        Guid? id, string? name, string? description, string? instructions,
        CancellationToken cancellationToken)
    {
        return connection.CommitUpdateRecipeDetailsAsync(
            id, name, description, instructions,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static async Task<int> CommitUpdateRecipeDetailsAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitUpdateRecipeDetailsAsync(
            id, name, description, instructions,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateRecipeDetailsAsync"/>
    public static Task<int> CommitUpdateRecipeDetailsAsync(this DbDataSource database,
        Guid? id, string? name, string? description, string? instructions,
        CancellationToken cancellationToken)
    {
        return database.CommitUpdateRecipeDetailsAsync(
            id, name, description, instructions,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'UpdateIngredient' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="description">The query parameter Description of type String.</param>
    /// <param name="number">The query parameter Number of type Object.</param>
    /// <param name="numberValue">The query parameter NumberValue of type Object.</param>
    /// <param name="numberUnit">The query parameter NumberUnit of type Object.</param>
    /// <param name="quantity">The query parameter Quantity of type Object.</param>
    /// <param name="quantityValue">The query parameter QuantityValue of type Object.</param>
    /// <param name="quantityUnit">The query parameter QuantityUnit of type Object.</param>
    /// <param name="altQuantity">The query parameter AltQuantity of type Object.</param>
    /// <param name="altQuantityValue">The query parameter AltQuantityValue of type Object.</param>
    /// <param name="altQuantityUnit">The query parameter AltQuantityUnit of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     update book.Ingredients
    ///     set Description = @Description,
    ///         Number = @Number, NumberValue = @NumberValue, NumberUnit = @NumberUnit,
    ///         Quantity = @Quantity, QuantityValue = @QuantityValue, QuantityUnit = @QuantityUnit,
    ///         AltQuantity = @AltQuantity, AltQuantityValue = @AltQuantityValue, AltQuantityUnit = @AltQuantityUnit
    ///     where Id = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> UpdateIngredientAsync(this DbConnection connection,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["UpdateIngredient"],
            param: new
            {
                Id = id,
                Description = description.AsNVarChar(100),
                Number = number,
                NumberValue = numberValue,
                NumberUnit = numberUnit,
                Quantity = quantity,
                QuantityValue = quantityValue,
                QuantityUnit = quantityUnit,
                AltQuantity = altQuantity,
                AltQuantityValue = altQuantityValue,
                AltQuantityUnit = altQuantityUnit
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static async Task<int> UpdateIngredientAsync(this DbDataSource database,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.UpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static Task<int> UpdateIngredientAsync(this DbDataSource database,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return database.UpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static Task<int> UpdateIngredientAsync(this DbTransaction transaction,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.UpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static async Task<int> CommitUpdateIngredientAsync(this DbConnection connection,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.UpdateIngredientAsync(
                id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static Task<int> CommitUpdateIngredientAsync(this DbConnection connection,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return connection.CommitUpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static async Task<int> CommitUpdateIngredientAsync(this DbDataSource database,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitUpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="UpdateIngredientAsync"/>
    public static Task<int> CommitUpdateIngredientAsync(this DbDataSource database,
        Guid? id, string? description, Measure number, Fractional numberValue, DbEnum<MeasurementType>? numberUnit, Measure quantity, Fractional quantityValue, DbEnum<MeasurementType>? quantityUnit, Measure altQuantity, Fractional altQuantityValue, DbEnum<MeasurementType>? altQuantityUnit,
        CancellationToken cancellationToken)
    {
        return database.CommitUpdateIngredientAsync(
            id, description, number, numberValue, numberUnit, quantity, quantityValue, quantityUnit, altQuantity, altQuantityValue, altQuantityUnit,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'DeleteIngredientFoods' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="id">The query parameter Id of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     delete from book.IngredientFoods
    ///     where IngredientId = @Id;
    /// </code>
    /// </remarks>
    public static Task<int> DeleteIngredientFoodsAsync(this DbConnection connection,
        Guid? id,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["DeleteIngredientFoods"],
            param: new
            {
                Id = id
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static async Task<int> DeleteIngredientFoodsAsync(this DbDataSource database,
        Guid? id,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.DeleteIngredientFoodsAsync(
            id,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static Task<int> DeleteIngredientFoodsAsync(this DbDataSource database,
        Guid? id,
        CancellationToken cancellationToken)
    {
        return database.DeleteIngredientFoodsAsync(
            id,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static Task<int> DeleteIngredientFoodsAsync(this DbTransaction transaction,
        Guid? id,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.DeleteIngredientFoodsAsync(
            id,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static async Task<int> CommitDeleteIngredientFoodsAsync(this DbConnection connection,
        Guid? id,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.DeleteIngredientFoodsAsync(
                id,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static Task<int> CommitDeleteIngredientFoodsAsync(this DbConnection connection,
        Guid? id,
        CancellationToken cancellationToken)
    {
        return connection.CommitDeleteIngredientFoodsAsync(
            id,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static async Task<int> CommitDeleteIngredientFoodsAsync(this DbDataSource database,
        Guid? id,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitDeleteIngredientFoodsAsync(
            id,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="DeleteIngredientFoodsAsync"/>
    public static Task<int> CommitDeleteIngredientFoodsAsync(this DbDataSource database,
        Guid? id,
        CancellationToken cancellationToken)
    {
        return database.CommitDeleteIngredientFoodsAsync(
            id,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'AddFood' and returns the first column of the first row in the result set returned by the query.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="name">The query parameter Name of type String.</param>
    /// <param name="shortName">The query parameter ShortName of type String.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The first column of the first row in the result set, or a null reference if the result set is empty.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.Foods (Name, ShortName)
    ///     output inserted.Id
    ///     values (@Name, @ShortName);
    /// </code>
    /// </remarks>
    public static Task<T?> AddFoodAsync<T>(this DbConnection connection,
        string? name, string? shortName,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteScalarAsync<T>(sql["AddFood"],
            param: new
            {
                Name = name.AsNVarChar(50),
                ShortName = shortName.AsNVarChar(50)
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static async Task<T?> AddFoodAsync<T>(this DbDataSource database,
        string? name, string? shortName,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.AddFoodAsync<T>(
            name, shortName,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static Task<T?> AddFoodAsync<T>(this DbDataSource database,
        string? name, string? shortName,
        CancellationToken cancellationToken)
    {
        return database.AddFoodAsync<T>(
            name, shortName,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static Task<T?> AddFoodAsync<T>(this DbTransaction transaction,
        string? name, string? shortName,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.AddFoodAsync<T>(
            name, shortName,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static async Task<T?> CommitAddFoodAsync<T>(this DbConnection connection,
        string? name, string? shortName,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.AddFoodAsync<T>(
                name, shortName,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static Task<T?> CommitAddFoodAsync<T>(this DbConnection connection,
        string? name, string? shortName,
        CancellationToken cancellationToken)
    {
        return connection.CommitAddFoodAsync<T>(
            name, shortName,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static async Task<T?> CommitAddFoodAsync<T>(this DbDataSource database,
        string? name, string? shortName,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitAddFoodAsync<T>(
            name, shortName,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="AddFoodAsync"/>
    public static Task<T?> CommitAddFoodAsync<T>(this DbDataSource database,
        string? name, string? shortName,
        CancellationToken cancellationToken)
    {
        return database.CommitAddFoodAsync<T>(
            name, shortName,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a command 'ConnectIngredientFood' and returns the number of rows affected.
    /// </summary>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="ingredientId">The query parameter IngredientId of type Guid.</param>
    /// <param name="foodId">The query parameter FoodId of type Guid.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The number of rows affected.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     insert into book.IngredientFoods (IngredientId, FoodId)
    ///     values (@IngredientId, @FoodId);
    /// </code>
    /// </remarks>
    public static Task<int> ConnectIngredientFoodAsync(this DbConnection connection,
        Guid? ingredientId, Guid? foodId,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.ExecuteAsync(sql["ConnectIngredientFood"],
            param: new
            {
                IngredientId = ingredientId,
                FoodId = foodId
            },
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static async Task<int> ConnectIngredientFoodAsync(this DbDataSource database,
        Guid? ingredientId, Guid? foodId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.ConnectIngredientFoodAsync(
            ingredientId, foodId,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static Task<int> ConnectIngredientFoodAsync(this DbDataSource database,
        Guid? ingredientId, Guid? foodId,
        CancellationToken cancellationToken)
    {
        return database.ConnectIngredientFoodAsync(
            ingredientId, foodId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static Task<int> ConnectIngredientFoodAsync(this DbTransaction transaction,
        Guid? ingredientId, Guid? foodId,
        int? commandTimeout = null, CommandType? commandType = null)
    {
        return transaction.Connection!.ConnectIngredientFoodAsync(
            ingredientId, foodId,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static async Task<int> CommitConnectIngredientFoodAsync(this DbConnection connection,
        Guid? ingredientId, Guid? foodId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var transaction = await connection.BeginTransactionAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            var returnValue = await transaction.ConnectIngredientFoodAsync(
                ingredientId, foodId,
                commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
            await transaction.CommitAsync(cancellationToken).ConfigureAwait(false);

            return returnValue;
        }
        catch (Exception exception) when (exception is not OperationCanceledException)
        {
            await transaction.RollbackAsync(cancellationToken).ConfigureAwait(false);
            throw;
        }
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static Task<int> CommitConnectIngredientFoodAsync(this DbConnection connection,
        Guid? ingredientId, Guid? foodId,
        CancellationToken cancellationToken)
    {
        return connection.CommitConnectIngredientFoodAsync(
            ingredientId, foodId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static async Task<int> CommitConnectIngredientFoodAsync(this DbDataSource database,
        Guid? ingredientId, Guid? foodId,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.CommitConnectIngredientFoodAsync(
            ingredientId, foodId,
            commandTimeout: commandTimeout, commandType: commandType, cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc cref="ConnectIngredientFoodAsync"/>
    public static Task<int> CommitConnectIngredientFoodAsync(this DbDataSource database,
        Guid? ingredientId, Guid? foodId,
        CancellationToken cancellationToken)
    {
        return database.CommitConnectIngredientFoodAsync(
            ingredientId, foodId,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a query 'SearchRecipesFullText' and returns the results as an <see cref="IEnumerable{T}" />.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="paramObject">The query parameter ParamObject of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The results as an <see cref="IEnumerable{T}" />.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select @TotalCount = count(r.Id)
    ///     from book.Recipes r;
    ///
    ///     select @FilterCount = count(r.Id)
    ///     from book.Recipes r
    ///     inner join freetexttable(book.Recipes, Name, @Search, @TopN) ft on ft.[Key] = r.Id;
    ///
    ///     select r.Id, r.Name, rs.Link, r.Description
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     inner join freetexttable(book.Recipes, Name, @Search, @TopN) ft on ft.[Key] = r.Id
    ///     order by ft.Rank desc, len(r.Instructions) desc
    ///     offset @SkipCount rows fetch next @TakeCount rows only;
    /// </code>
    /// </remarks>
    public static Task<IEnumerable<T>> SearchRecipesFullTextAsync<T>(this DbConnection connection,
        object paramObject,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryAsync<T>(sql["SearchRecipesFullText"],
            param: paramObject,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="SearchRecipesFullTextAsync"/>
    public static async Task<IEnumerable<T>> SearchRecipesFullTextAsync<T>(this DbDataSource database,
        object paramObject,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.SearchRecipesFullTextAsync<T>(
            paramObject,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="SearchRecipesFullTextAsync"/>
    public static Task<IEnumerable<T>> SearchRecipesFullTextAsync<T>(this DbDataSource database,
        object paramObject,
        CancellationToken cancellationToken)
    {
        return database.SearchRecipesFullTextAsync<T>(
            paramObject,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }

    /// <summary>
    /// Executes a query 'SearchRecipes' and returns the results as an <see cref="IEnumerable{T}" />.
    /// </summary>
    /// <typeparam name="T">The type of the result.</typeparam>
    /// <param name="connection">The connection to use for this query.</param>
    /// <param name="paramObject">The query parameter paramObject of type Object.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>
    /// The results as an <see cref="IEnumerable{T}" />.
    /// </returns>
    /// <remarks>
    /// The SQL script used to generate this method:
    /// <code>
    ///     select @TotalCount = count(r.Id)
    ///     from book.Recipes r;
    ///
    ///     --select @FilterCount = count(distinct r.Id)
    ///     --from book.Recipes r
    ///     --left outer join book.RecipeFoods rf on rf.RecipeId = r.Id
    ///     --left outer join book.Foods f on f.Id = rf.FoodId
    ///     --where
    ///     --    charindex(@Search, r.Name) > 0 or
    ///     --    charindex(@Search, r.Description) > 0 or
    ///     --    charindex(@Search, r.Instructions) > 0 or
    ///     --    charindex(@Search, f.Name) > 0;
    ///
    ///     select distinct r.Id, r.Name, rs.Link, r.Description, len(r.Instructions) as Care
    ///     from book.Recipes r
    ///     inner join book.RecipeSources rs on rs.RecipeId = r.Id
    ///     left outer join book.RecipeFoods rf on rf.RecipeId = r.Id
    ///     left outer join book.Foods f on f.Id = rf.FoodId
    ///     where
    ///         charindex(@Search, r.Name) > 0 or
    ///         charindex(@Search, r.Description) > 0 or
    ///         charindex(@Search, r.Instructions) > 0 or
    ///         charindex(@Search, f.Name) > 0
    ///     order by Care desc
    ///     offset @SkipCount rows fetch next @TakeCount rows only;
    ///
    ///     select @FilterCount = @@RowCount;
    /// </code>
    /// </remarks>
    public static Task<IEnumerable<T>> SearchRecipesAsync<T>(this DbConnection connection,
        object paramObject,
        IDbTransaction? transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        return connection.QueryAsync<T>(sql["SearchRecipes"],
            param: paramObject,
            transaction: transaction, commandTimeout: commandTimeout, commandType: commandType);
    }

    /// <inheritdoc cref="SearchRecipesAsync"/>
    public static async Task<IEnumerable<T>> SearchRecipesAsync<T>(this DbDataSource database,
        object paramObject,
        int? commandTimeout = null, CommandType? commandType = null, CancellationToken cancellationToken = default)
    {
        await using var connection = await database.OpenConnectionAsync(cancellationToken).ConfigureAwait(false);
        return await connection.SearchRecipesAsync<T>(
            paramObject,
            commandTimeout: commandTimeout, commandType: commandType).ConfigureAwait(false);
    }

    /// <inheritdoc cref="SearchRecipesAsync"/>
    public static Task<IEnumerable<T>> SearchRecipesAsync<T>(this DbDataSource database,
        object paramObject,
        CancellationToken cancellationToken)
    {
        return database.SearchRecipesAsync<T>(
            paramObject,
            commandTimeout: null, commandType: null, cancellationToken: cancellationToken);
    }
}
